File: c:\Users\SUN\Desktop\programs\IBDP-SIMS\indexengineer/src/app/scheduler/page.tsx

// src/app/scheduler/page.tsx
"use client";

import React, { useState, useEffect } from 'react';
import { Plus, Calendar, Filter, Search } from 'lucide-react';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { useRouter } from 'next/navigation';

const TaskForm = ({ onSubmit, initialData = null, onClose }: any) => {
  const [task, setTask] = useState<Partial<Task>>(
  initialData || {
    title: '',
    description: '',
    category: 'Academic',
    priority: 'Medium',
    status: 'Pending',
    dueDate: new Date().toISOString().split('T')[0],
    concepts: [],
  }
  );

  const handleSubmit = (e: React.FormEvent) => {
  e.preventDefault();
  onSubmit({ ...task, id: initialData?.id || crypto.randomUUID() });
  onClose();
  };

  return (
  <form onSubmit={handleSubmit} className="space-y-4">
    <Input
    placeholder="Task Title"
    value={task.title}
    onChange={(e) => setTask({ ...task, title: e.target.value })}
    required
    />
    <Textarea
    placeholder="Description"
    value={task.description}
    onChange={(e) => setTask({ ...task, description: e.target.value })}
    />
    <div className="grid grid-cols-2 gap-4">
    <Select
      value={task.category}
      onValueChange={(value) => setTask({ ...task, category: value as Category })}
    >
      <SelectTrigger>
      <SelectValue placeholder="Category" />
      </SelectTrigger>
      <SelectContent>
      <SelectItem value="Academic">Academic</SelectItem>
      <SelectItem value="University">University</SelectItem>
      <SelectItem value="Sports">Sports</SelectItem>
      <SelectItem value="Extracurricular">Extracurricular</SelectItem>
      <SelectItem value="Mental Health">Mental Health</SelectItem>
      </SelectContent>
    </Select>
    <Select
      value={task.priority}
      onValueChange={(value) => setTask({ ...task, priority: value as Priority })}
    >
      <SelectTrigger>
      <SelectValue placeholder="Priority" />
      </SelectTrigger>
      <SelectContent>
      <SelectItem value="Low">Low</SelectItem>
      <SelectItem value="Medium">Medium</SelectItem>
      <SelectItem value="High">High</SelectItem>
      </SelectContent>
    </Select>
    </div>
    <Input
    type="date"
    value={task.dueDate}
    onChange={(e) => setTask({ ...task, dueDate: e.target.value })}
    />
    {task.category === 'Academic' && (
    <div className="space-y-4">
      <Input
      placeholder="Subject"
      value={task.subject}
      onChange={(e) => setTask({ ...task, subject: e.target.value })}
      />
      <Textarea
      placeholder="Syllabus Topics"
      value={task.syllabus}
      onChange={(e) => setTask({ ...task, syllabus: e.target.value })}
      />
      <Input
      placeholder="Add concepts (comma-separated)"
      value={task.concepts?.join(', ')}
      onChange={(e) => setTask({ 
        ...task, 
        concepts: e.target.value.split(',').map(c => c.trim()).filter(Boolean)
      })}
      />
    </div>
    )}
    <Button type="submit" className="w-full">
    {initialData ? 'Update Task' : 'Create Task'}
    </Button>
  </form>
  );
};

const TaskCard = ({ task, onEdit, onDelete, onStatusChange }: any) => {
  const getPriorityColor = (priority: Priority) => {
  const colors = {
    Low: 'bg-green-100 text-green-800',
    Medium: 'bg-yellow-100 text-yellow-800',
    High: 'bg-red-100 text-red-800'
  };
  return colors[priority];
  };

  const getStatusColor = (status: Status) => {
  const colors = {
    Pending: 'bg-gray-100 text-gray-800',
    'In Progress': 'bg-blue-100 text-blue-800',
    Completed: 'bg-green-100 text-green-800'
  };
  return colors[status];
  };

  return (
  <Card className="mb-4">
    <CardHeader>
    <div className="flex justify-between items-start">
      <div>
      <CardTitle>{task.title}</CardTitle>
      <CardDescription>{task.description}</CardDescription>
      </div>
      <div className="flex gap-2">
      <Badge className={getPriorityColor(task.priority)}>{task.priority}</Badge>
      <Badge className={getStatusColor(task.status)}>{task.status}</Badge>
      </div>
    </div>
    </CardHeader>
    <CardContent>
    <div className="space-y-2">
      <p className="text-sm">Due: {new Date(task.dueDate).toLocaleDateString()}</p>
      {task.subject && <p className="text-sm">Subject: {task.subject}</p>}
      {task.concepts?.length > 0 && (
      <div className="flex flex-wrap gap-2">
        {task.concepts.map((concept: string, index: number) => (
        <Badge key={index} variant="outline">{concept}</Badge>
        ))}
      </div>
      )}
    </div>
    </CardContent>
    <CardFooter className="justify-between">
    <Select
      value={task.status}
      onValueChange={(value) => onStatusChange(task.id, value)}
    >
      <SelectTrigger className="w-32">
      <SelectValue />
      </SelectTrigger>
      <SelectContent>
      <SelectItem value="Pending">Pending</SelectItem>
      <SelectItem value="In Progress">In Progress</SelectItem>
      <SelectItem value="Completed">Completed</SelectItem>
      </SelectContent>
    </Select>
    <div className="space-x-2">
      <Button variant="outline" size="sm" onClick={() => onEdit(task)}>
      Edit
      </Button>
      <Button variant="destructive" size="sm" onClick={() => onDelete(task.id)}>
      Delete
      </Button>
    </div>
    </CardFooter>
  </Card>
  );
};

export default function SchedulerPage() {
  const router = useRouter();
  const [tasks, setTasks] = useState<Task[]>([]);
  const [filter, setFilter] = useState<Status | 'All'>('All');
  const [search, setSearch] = useState('');
  const [editTask, setEditTask] = useState<Task | null>(null);
  const [isDialogOpen, setIsDialogOpen] = useState(false);

  useEffect(() => {
    const fetchTasks = async () => {
      try {
        const response = await fetch('/api/data?type=tasks');
        if (!response.ok) throw new Error('Failed to fetch tasks');
        const data = await response.json();
        setTasks(data);
      } catch (error) {
        console.error('Error fetching tasks:', error);
        // Fallback to localStorage if API fails
        const savedTasks = localStorage.getItem('tasks');
        if (savedTasks) {
          setTasks(JSON.parse(savedTasks));
        }
      }
    };

    fetchTasks();
  }, []);

  useEffect(() => {
    const saveTasks = async () => {
      try {
        const response = await fetch('/api/data?type=tasks', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(tasks),
        });

        if (!response.ok) throw new Error('Failed to save tasks');
        
        // Keep localStorage as backup
        localStorage.setItem('tasks', JSON.stringify(tasks));
      } catch (error) {
        console.error('Error saving tasks:', error);
        // Ensure localStorage backup is still updated
        localStorage.setItem('tasks', JSON.stringify(tasks));
      }
    };

    if (tasks.length > 0) {
      saveTasks();
    }
  }, [tasks]);

  const handleSubmit = (task: Task) => {
  if (editTask) {
    setTasks(tasks.map(t => t.id === task.id ? task : t));
  } else {
    setTasks([...tasks, task]);
  }
  };

  const handleDelete = async (id: string) => {
    const updatedTasks = tasks.filter(task => task.id !== id);
    setTasks(updatedTasks);
    
    try {
      const response = await fetch('/api/data?type=tasks', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updatedTasks),
      });
  
      if (!response.ok) throw new Error('Failed to save tasks');
      
      // Update localStorage only after successful API call
      localStorage.setItem('tasks', JSON.stringify(updatedTasks));
    } catch (error) {
      console.error('Error saving tasks:', error);
      // Fallback to localStorage if API fails
      localStorage.setItem('tasks', JSON.stringify(updatedTasks));
    }
  };

  const handleStatusChange = (id: string, status: Status) => {
  setTasks(tasks.map(task => 
    task.id === id ? { ...task, status } : task
  ));
  };

  const handleEdit = (task: Task) => {
  setEditTask(task);
  setIsDialogOpen(true);
  };

  const filteredTasks = tasks
  .filter(task => filter === 'All' || task.status === filter)
  .filter(task => 
    task.title.toLowerCase().includes(search.toLowerCase()) ||
    task.description.toLowerCase().includes(search.toLowerCase())
  );

  return (
  <div className="max-w-4xl mx-auto py-8">
    <div className="flex justify-between items-center mb-6">
      <h1 className="text-3xl font-bold">Task Scheduler</h1>
      <div className="flex gap-2">
        <Button variant="outline" onClick={() => router.push('/scheduler/tracking')}>
          <Calendar className="mr-2 h-4 w-4" /> Track Progress
        </Button>
        <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
          <DialogTrigger asChild>
            <Button>
              <Plus className="mr-2 h-4 w-4" /> Add Task
            </Button>
          </DialogTrigger>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>{editTask ? 'Edit Task' : 'Create New Task'}</DialogTitle>
            </DialogHeader>
            <TaskForm
              onSubmit={handleSubmit}
              initialData={editTask}
              onClose={() => {
                setIsDialogOpen(false);
                setEditTask(null);
              }}
            />
          </DialogContent>
        </Dialog>
      </div>
    </div>

    <div className="flex gap-4 mb-6">
    <div className="flex-1">
      <div className="relative">
        <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
        <Input
          placeholder="Search tasks..."
          value={search}
          onChange={(e) => setSearch(e.target.value)}
          className="w-full pl-10"
        />
      </div>
    </div>
    <Select value={filter} onValueChange={(value: any) => setFilter(value)}>
      <SelectTrigger className="w-32">
      <SelectValue placeholder="Filter" />
      </SelectTrigger>
      <SelectContent>
      <SelectItem value="All">All</SelectItem>
      <SelectItem value="Pending">Pending</SelectItem>
      <SelectItem value="In Progress">In Progress</SelectItem>
      <SelectItem value="Completed">Completed</SelectItem>
      </SelectContent>
    </Select>
    </div>

    <Tabs defaultValue="all" className="w-full">
    <TabsList className="mb-4">
      <TabsTrigger value="all">All Tasks</TabsTrigger>
      <TabsTrigger value="academic">Academic</TabsTrigger>
      <TabsTrigger value="university">University</TabsTrigger>
      <TabsTrigger value="other">Other</TabsTrigger>
    </TabsList>

    <ScrollArea className="h-[calc(100vh-300px)]">
      <TabsContent value="all">
      {filteredTasks.map(task => (
        <TaskCard
        key={task.id}
        task={task}
        onEdit={handleEdit}
        onDelete={handleDelete}
        onStatusChange={handleStatusChange}
        />
      ))}
      </TabsContent>

      <TabsContent value="academic">
      {filteredTasks
        .filter(task => task.category === 'Academic')
        .map(task => (
        <TaskCard
          key={task.id}
          task={task}
          onEdit={handleEdit}
          onDelete={handleDelete}
          onStatusChange={handleStatusChange}
        />
        ))}
      </TabsContent>

      <TabsContent value="university">
      {filteredTasks
        .filter(task => task.category === 'University')
        .map(task => (
        <TaskCard
          key={task.id}
          task={task}
          onEdit={handleEdit}
          onDelete={handleDelete}
          onStatusChange={handleStatusChange}
        />
        ))}
      </TabsContent>

      <TabsContent value="other">
      {filteredTasks
        .filter(task => !['Academic', 'University'].includes(task.category))
        .map(task => (
        <TaskCard
          key={task.id}
          task={task}
          onEdit={handleEdit}
          onDelete={handleDelete}
          onStatusChange={handleStatusChange}
        />
        ))}
      </TabsContent>
    </ScrollArea>
    </Tabs>
  </div>
  );
}

================================================================================

File: c:\Users\SUN\Desktop\programs\IBDP-SIMS\indexengineer/src/components/Calendar.tsx

"use client";

import React from "react";
import { Task } from "@/types/task";

interface CalendarProps {
  tasks: Task[];
}

export default function Calendar({ tasks }: CalendarProps) {
  const today = new Date();
  const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
  const lastDayOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0);

  const daysInMonth = lastDayOfMonth.getDate();
  const startingDay = firstDayOfMonth.getDay();

  const calendar = [];
  let day = 1;

  for (let i = 0; i < 6; i++) {
    const week = [];
    for (let j = 0; j < 7; j++) {
      if (i === 0 && j < startingDay) {
        week.push(<td key={`empty-${j}`} className="p-2 border"></td>);
      } else if (day > daysInMonth) {
        break;
      } else {
        const currentDate = new Date(
          today.getFullYear(),
          today.getMonth(),
          day
        );
        const tasksForDay = tasks.filter(
          (task) =>
            new Date(task.date).toDateString() === currentDate.toDateString()
        );
        week.push(
          <td key={day} className="p-2 border">
            <div className="font-bold">{day}</div>
            {tasksForDay.map((task) => (
              <div
                key={task.id}
                className="text-xs bg-blue-100 p-1 mt-1 rounded"
              >
                {task.title}
              </div>
            ))}
          </td>
        );
        day++;
      }
    }
    calendar.push(<tr key={i}>{week}</tr>);
    if (day > daysInMonth) break;
  }

  return (
    <div className="mt-4">
      <h2 className="text-xl font-bold mb-2">Calendar</h2>
      <table className="w-full border-collapse">
        <thead>
          <tr>
            {["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"].map((day) => (
              <th key={day} className="p-2 border">
                {day}
              </th>
            ))}
          </tr>
        </thead>
        <tbody>{calendar}</tbody>
      </table>
    </div>
  );
}


================================================================================

File: c:\Users\SUN\Desktop\programs\IBDP-SIMS\indexengineer/src/app/scheduler/Types.ts

// src/app/scheduler/Types.ts

declare global {
  type Priority = 'Low' | 'Medium' | 'High';
  type Status = 'Pending' | 'In Progress' | 'Completed';
  type Category = 'Academic' | 'University' | 'Sports' | 'Extracurricular' | 'Mental Health';

  interface Task {
    id: string;
    title: string;
    description: string;
    category: Category;
    priority: Priority;
    status: Status;
    dueDate: string;
    subject?: string;
    syllabus?: string;
    concepts?: string[];
    reviewDates: string[];
    lastReviewDate?: string;
  }
}

// This empty export makes the file a module
export {};

================================================================================

File: c:\Users\SUN\Desktop\programs\IBDP-SIMS\indexengineer/src/types/task.ts

export interface Task {
    id: number;
    title: string;
    date: string;
    duration: number;
  }

================================================================================

File: c:\Users\SUN\Desktop\programs\IBDP-SIMS\indexengineer/src/lib/data.ts

// src/lib/data.ts
import fs from 'fs';
import path from 'path';
import { Task } from '@/types/task';

const DATA_DIR = path.join(process.cwd(), 'data');
const TASKS_FILE = path.join(DATA_DIR, 'tasks.json');
const TRACKING_FILE = path.join(DATA_DIR, 'tracking.json');

// Ensure data directory exists
if (!fs.existsSync(DATA_DIR)) {
  fs.mkdirSync(DATA_DIR, { recursive: true });
}

// Initialize files with empty arrays if they don't exist
[TASKS_FILE, TRACKING_FILE].forEach(file => {
  if (!fs.existsSync(file)) {
    fs.writeFileSync(file, '[]', 'utf-8');
  }
});

export async function readData(type: 'tasks' | 'tracking') {
  const file = type === 'tasks' ? TASKS_FILE : TRACKING_FILE;
  try {
    const data = await fs.promises.readFile(file, 'utf-8');
    return JSON.parse(data);
  } catch (error) {
    console.error(`Error reading ${type}:`, error);
    return [];
  }
}

export async function writeData(type: 'tasks' | 'tracking', data: any) {
  const file = type === 'tasks' ? TASKS_FILE : TRACKING_FILE;
  try {
    await fs.promises.writeFile(file, JSON.stringify(data, null, 2), 'utf-8');
    return true;
  } catch (error) {
    console.error(`Error writing ${type}:`, error);
    return false;
  }
}

// API route handlers
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const type = searchParams.get('type') as 'tasks' | 'tracking';

  if (!type || !['tasks', 'tracking'].includes(type)) {
    return new Response('Invalid type parameter', { status: 400 });
  }

  const data = await readData(type);
  return new Response(JSON.stringify(data), {
    headers: { 'Content-Type': 'application/json' },
  });
}

export async function POST(request: Request) {
  const { searchParams } = new URL(request.url);
  const type = searchParams.get('type') as 'tasks' | 'tracking';

  if (!type || !['tasks', 'tracking'].includes(type)) {
    return new Response('Invalid type parameter', { status: 400 });
  }

  try {
    const body = await request.json();
    const success = await writeData(type, body);
    
    if (!success) {
      throw new Error('Failed to write data');
    }

    return new Response(JSON.stringify({ success: true }), {
      headers: { 'Content-Type': 'application/json' },
    });
  } catch (error) {
    return new Response(JSON.stringify({ 
      success: false, 
      error: 'Failed to process request' 
    }), { 
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    });
  }
}

================================================================================

File: c:\Users\SUN\Desktop\programs\IBDP-SIMS\indexengineer/src/app/api/data/route.ts

// src/app/api/data/route.ts
export { GET, POST } from '@/lib/data';

================================================================================

File: c:\Users\SUN\Desktop\programs\IBDP-SIMS\indexengineer/src/app/scheduler/tracking/page.tsx

// src/app/scheduler/tracking/page.tsx
"use client";

import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { ArrowLeft, Edit, Trash2 } from 'lucide-react';
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";

interface TrackingEntry {
  id: string;
  taskId: string;
  date: string;
  qualitativeNotes: string;
  effectiveness: 1 | 2 | 3 | 4 | 5;
  challenges: string;
  nextSteps: string;
}

export default function TrackingPage() {
  const router = useRouter();
  const [tasks, setTasks] = useState<Task[]>([]);
  const [selectedTask, setSelectedTask] = useState<string>('');
  const [trackingEntries, setTrackingEntries] = useState<TrackingEntry[]>([]);
  const [currentEntry, setCurrentEntry] = useState<Partial<TrackingEntry>>({
    date: new Date().toISOString().split('T')[0],
    effectiveness: 3
  });
  const [editingEntry, setEditingEntry] = useState<TrackingEntry | null>(null);
  const [isDialogOpen, setIsDialogOpen] = useState(false);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const tasksResponse = await fetch('/api/data?type=tasks');
        const tasksData = await tasksResponse.json();
        setTasks(tasksData);

        const trackingResponse = await fetch('/api/data?type=tracking');
        const trackingData = await trackingResponse.json();
        setTrackingEntries(trackingData);
      } catch (error) {
        console.error('Error fetching data:', error);
        const savedTasks = localStorage.getItem('tasks');
        const savedEntries = localStorage.getItem('trackingEntries');
        if (savedTasks) setTasks(JSON.parse(savedTasks));
        if (savedEntries) setTrackingEntries(JSON.parse(savedEntries));
      }
    };

    fetchData();
  }, []);

  useEffect(() => {
    const saveTrackingEntries = async () => {
      try {
        await fetch('/api/data?type=tracking', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(trackingEntries),
        });
        localStorage.setItem('trackingEntries', JSON.stringify(trackingEntries));
      } catch (error) {
        console.error('Error saving tracking entries:', error);
        localStorage.setItem('trackingEntries', JSON.stringify(trackingEntries));
      }
    };

    if (trackingEntries.length > 0) {
      saveTrackingEntries();
    }
  }, [trackingEntries]);

  const validateEntry = (entry: Partial<TrackingEntry>) => {
    if (!entry.taskId || !entry.date || !entry.qualitativeNotes) {
      return false;
    }
    return true;
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validateEntry(currentEntry)) {
      alert('Please fill in all required fields (Task, Date, and Notes)');
      return;
    }

    const newEntry: TrackingEntry = {
      id: editingEntry?.id || crypto.randomUUID(),
      taskId: selectedTask,
      date: currentEntry.date || new Date().toISOString().split('T')[0],
      qualitativeNotes: currentEntry.qualitativeNotes || '',
      effectiveness: currentEntry.effectiveness as 1 | 2 | 3 | 4 | 5,
      challenges: currentEntry.challenges || '',
      nextSteps: currentEntry.nextSteps || ''
    };

    if (editingEntry) {
      setTrackingEntries(entries => 
        entries.map(e => e.id === editingEntry.id ? newEntry : e)
      );
    } else {
      setTrackingEntries(entries => [...entries, newEntry]);
    }

    // Reset form
    setCurrentEntry({
      date: new Date().toISOString().split('T')[0],
      effectiveness: 3
    });
    setSelectedTask('');
    setEditingEntry(null);
    setIsDialogOpen(false);
  };

  const handleEdit = (entry: TrackingEntry) => {
    setEditingEntry(entry);
    setSelectedTask(entry.taskId);
    setCurrentEntry({
      date: entry.date,
      qualitativeNotes: entry.qualitativeNotes,
      effectiveness: entry.effectiveness,
      challenges: entry.challenges,
      nextSteps: entry.nextSteps
    });
    setIsDialogOpen(true);
  };

  const handleDelete = (entryId: string) => {
    if (window.confirm('Are you sure you want to delete this entry?')) {
      setTrackingEntries(entries => entries.filter(e => e.id !== entryId));
    }
  };

  const getTaskById = (id: string) => tasks.find(t => t.id === id);

  return (
    <div className="max-w-4xl mx-auto py-8">
      <div className="flex items-center gap-4 mb-6">
        <Button variant="ghost" onClick={() => router.push('/scheduler')}>
          <ArrowLeft className="h-4 w-4 mr-2" />
          Back to Scheduler
        </Button>
        <h1 className="text-3xl font-bold">Task Tracking</h1>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
          <DialogTrigger asChild>
            <Button className="mb-4">
              {editingEntry ? 'Edit Entry' : 'New Entry'}
            </Button>
          </DialogTrigger>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>{editingEntry ? 'Edit Entry' : 'New Tracking Entry'}</DialogTitle>
            </DialogHeader>
            <form onSubmit={handleSubmit} className="space-y-4">
              <Select
                value={selectedTask}
                onValueChange={setSelectedTask}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Select Task" />
                </SelectTrigger>
                <SelectContent>
                  {tasks.map(task => (
                    <SelectItem key={task.id} value={task.id}>
                      {task.title}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>

              <input
                type="date"
                className="w-full px-3 py-2 border rounded-md"
                value={currentEntry.date}
                onChange={e => setCurrentEntry({...currentEntry, date: e.target.value})}
              />

              <Textarea
                placeholder="Qualitative Notes"
                value={currentEntry.qualitativeNotes}
                onChange={e => setCurrentEntry({...currentEntry, qualitativeNotes: e.target.value})}
              />

              <Select
                value={currentEntry.effectiveness?.toString()}
                onValueChange={value => setCurrentEntry({...currentEntry, effectiveness: parseInt(value) as 1 | 2 | 3 | 4 | 5})}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Effectiveness Rating" />
                </SelectTrigger>
                <SelectContent>
                  {[1, 2, 3, 4, 5].map(rating => (
                    <SelectItem key={rating} value={rating.toString()}>
                      {rating} - {rating === 1 ? 'Poor' : rating === 5 ? 'Excellent' : ''}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>

              <Textarea
                placeholder="Challenges Faced"
                value={currentEntry.challenges}
                onChange={e => setCurrentEntry({...currentEntry, challenges: e.target.value})}
              />

              <Textarea
                placeholder="Next Steps"
                value={currentEntry.nextSteps}
                onChange={e => setCurrentEntry({...currentEntry, nextSteps: e.target.value})}
              />

              <Button type="submit" className="w-full">
                {editingEntry ? 'Update Entry' : 'Save Entry'}
              </Button>
            </form>
          </DialogContent>
        </Dialog>

        <Card>
          <CardHeader>
            <CardTitle>Recent Entries</CardTitle>
          </CardHeader>
          <CardContent>
            <ScrollArea className="h-[600px] pr-4">
              {trackingEntries
                .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
                .map((entry) => {
                  const task = getTaskById(entry.taskId);
                  return (
                    <Card key={entry.id} className="mb-4">
                      <CardContent className="pt-6">
                        <div className="space-y-2">
                          <div className="flex justify-between items-start">
                            <h3 className="font-semibold">{task?.title || 'Unknown Task'}</h3>
                            <div className="flex gap-2">
                              <Badge>{new Date(entry.date).toLocaleDateString()}</Badge>
                              <Button
                                variant="ghost"
                                size="sm"
                                onClick={() => handleEdit(entry)}
                              >
                                <Edit className="h-4 w-4" />
                              </Button>
                              <Button
                                variant="ghost"
                                size="sm"
                                onClick={() => handleDelete(entry.id)}
                              >
                                <Trash2 className="h-4 w-4" />
                              </Button>
                            </div>
                          </div>
                          <p className="text-sm text-gray-600">{entry.qualitativeNotes}</p>
                          <div className="flex gap-2">
                            <Badge variant="outline">
                              Effectiveness: {entry.effectiveness}/5
                            </Badge>
                          </div>
                          {entry.challenges && (
                            <div className="text-sm">
                              <strong>Challenges:</strong> {entry.challenges}
                            </div>
                          )}
                          {entry.nextSteps && (
                            <div className="text-sm">
                              <strong>Next Steps:</strong> {entry.nextSteps}
                            </div>
                          )}
                        </div>
                      </CardContent>
                    </Card>
                  );
                })}
            </ScrollArea>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}

================================================================================

